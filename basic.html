<!DOCTYPE HTML>
<html>
<head>
<title>3d Tile Test</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style type="text/css">
body { background: #bfd1e5; color: black; padding: 0; margin: 0; }
</style>
<script src="Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/RequestAnimationFrame.js"></script>
<script src="js/Stats.js"></script>
<script src="3hex.js"></script>
<script src="hex.js"></script>
</head>

<body>
<script type="text/javascript">
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;
var container = document.body;
var renderer = new THREE.WebGLRenderer();
var camera = new THREE.PerspectiveCamera(45, SCREEN_WIDTH/SCREEN_HEIGHT,
                                         1, 1000);
camera.position.z = 5;
camera.position.y = -5;
camera.lookAt(new THREE.Vector3(0,0,0));

var mouse = { x:0, y:0 };
var projector = new THREE.Projector();

var scene = new THREE.Scene();
//scene.fog = new THREE.FogExp2( 0xefd1b5, 0.08 );
scene.fog = new THREE.Fog( 0xefd1b5, 1, 20 );

var sunLight = new THREE.DirectionalLight(0xFFFFFF);
sunLight.position.x = 5;
sunLight.position.y = 5;
sunLight.position.z = 10;
sunLight.intensity = 0.8;
scene.add(sunLight);

var ambientLight = new THREE.AmbientLight( 0x404040 );
scene.add( ambientLight );

var tileMaterials = [];
// in order: mountain, grass, sea
var tileTextureNames = [ '2c', '2a', '2b' ];
var i;
for (i=0; i<tileTextureNames.length; i++) {
  tileMaterials.push(new THREE.MeshLambertMaterial(
    { map: THREE.ImageUtils.loadTexture('textures/tile-draft-' +
                                        tileTextureNames[i] + '-128.png'),
      shading: THREE.SmoothShading, color: 0xFFFFFF }));
}
var edgeTexture = THREE.ImageUtils.loadTexture( 'textures/acorns.jpg');
//var edgeTexture = THREE.ImageUtils.loadTexture( 'textures/UV.jpg' );
edgeTexture.wrapS = edgeTexture.wrapT = THREE.RepeatWrapping;
var edgeMaterial = new THREE.MeshLambertMaterial({map:edgeTexture});

// icon texture
var appTexture = THREE.ImageUtils.loadTexture("textures/tomas_arad_home.png");


var BASE_HEIGHT = .15;
var WATER_OFFSET = -.1, GRASS_OFFSET = 0, MOUNTAIN_OFFSET = .25;

// initialize the hexes and start drawin' 'em!
var x = hex_init();
var HVERT = x[0];
var HEXES = x[1];

// A = mountain, B = grass, C = sea
var COLOR_OFFSET = [ MOUNTAIN_OFFSET, GRASS_OFFSET, WATER_OFFSET ];
// 0 -> mountain->grass
// 1 -> grass->grass
// 2 -> grass->water
// 3 -> water->water
// 4 -> water->mountain
// 5 -> mountain->mountain
var COLOR_TABLE = [ /* mountain */ [  [5,false], [0,false], [4,true ] ],
                    /* grass */    [  [0,true ], [1,false], [2,false] ],
                    /* sea */      [  [4,false], [2,true ], [3,false] ] ];

function UVavg(uv1, uv2) {
  return new THREE.UV((uv1.u + uv2.u) / 2,
                      (uv1.v + uv2.v) / 2);
}
function subdivideGeometry(g) {
  var newf = [], newuv = [];
  var i;
  for (i=0; i<g.faces.length; i++) {
    var face = g.faces[i], uv = g.faceVertexUvs[0][i];
    console.assert(face instanceof THREE.Face3);
    // split each edge
    var a = g.vertices[face.a].position;
    var b = g.vertices[face.b].position;
    var c = g.vertices[face.c].position;
    var ab = a.clone().addSelf(b).divideScalar(2);
    var bc = b.clone().addSelf(c).divideScalar(2);
    var ca = c.clone().addSelf(a).divideScalar(2);

    var _ab = g.vertices.length;
    g.vertices.push(new THREE.Vertex(ab));
    var _bc = g.vertices.length;
    g.vertices.push(new THREE.Vertex(bc));
    var _ca = g.vertices.length;
    g.vertices.push(new THREE.Vertex(ca));

    var uv_ab = UVavg(uv[0], uv[1]);
    var uv_bc = UVavg(uv[1], uv[2]);
    var uv_ca = UVavg(uv[2], uv[0]);

    newf.push(new THREE.Face3(_ca, face.a, _ab));
    newuv.push             ([uv_ca, uv[0], uv_ab]);
    newf.push(new THREE.Face3(_ab, face.b, _bc));
    newuv.push             ([uv_ab, uv[1], uv_bc]);
    newf.push(new THREE.Face3(_bc, face.c, _ca));
    newuv.push             ([uv_bc, uv[2], uv_ca]);
    newf.push(new THREE.Face3(_ab, _bc, _ca));
    newuv.push             ([uv_ab, uv_bc, uv_ca]);
  }
  g.faces = newf;
  g.faceVertexUvs[0] = newuv;
  g.computeCentroids();
  g.computeFaceNormals();
}
function updateHex(scene, h, addEdges) {
    var i, k, s, n;
    if (h.objs && h.objs.length) {
      for (i=0; i<h.objs.length; i++) {
        scene.remove(h.objs[i]);
      }
    }
    h.objs = [];

    var xoff = (h.x-(HEXES[0].length/2))*1.5;
    var yoff = (h.y-(HEXES.length/2))*-SQRT3;
    if ((h.x%2)==1) { yoff += SQRT3/2; }

    var g = null, gg;
    for (k=0; k<6; k++) {
      var v1 = h.vertices[(k)%6], v2 = h.vertices[(k+1)%6];
      var uvRot = COLOR_TABLE[v1.color][v2.color];
      gg = new THREE.HexSegGeometry(k+1, uvRot[0], uvRot[1], BASE_HEIGHT,
                                    COLOR_OFFSET[v1.color],
                                    COLOR_OFFSET[v2.color], 0);
      if (g) { THREE.GeometryUtils.merge(g, gg); }
      else { g = gg; }
    }
    gg = new THREE.HexCoreGeometry(BASE_HEIGHT, COLOR_OFFSET[h.color]);
    subdivideGeometry(gg);
    THREE.GeometryUtils.merge(g, gg);

    // smooth rendering by computing appropriate vertex normals.
    g.mergeVertices();
    g.computeVertexNormals();

    // further hack to smooth tile boundaries
    function isOuterVertex(g, vidx) {
      var v = g.vertices[vidx];
      // midpoint of edges are 0.86 from center.  squared, that's 0.75
      return v.position.lengthSq() > 0.74;
    }
    for (i=0; i<g.faces.length; i++) {
      var face = g.faces[i];
      console.assert(face instanceof THREE.Face3);
      if (isOuterVertex(g, face.a)) { face.vertexNormals[0].set(0,0,1); }
      if (isOuterVertex(g, face.b)) { face.vertexNormals[1].set(0,0,1); }
      if (isOuterVertex(g, face.c)) { face.vertexNormals[2].set(0,0,1); }
    }

    s = new THREE.Mesh(g, tileMaterials[h.color]);
    s.position.x = xoff;
    s.position.y = yoff;
    h.objs.push(s);
    scene.add(s);

    // always add edges if this is a boundary hex.
    n = h.neighbors();
    for (k=0; k<6; k++) {
      if (HEXES[n[k][1]] && HEXES[n[k][1]][n[k][0]]) continue;
      addEdges = true;
    }

    // app icon
    /*
    var sprite = new THREE.Sprite(
      { map: appTexture, useScreenCoordinates: false, color: 0xffffff,
        alignment: THREE.SpriteAlignment.bottomCenter });
    sprite.position.set( xoff, yoff, BASE_HEIGHT+COLOR_OFFSET[h.color]);
    sprite.scale.set(1/128,1/128,1/128);
    h.objs.push(sprite);
    scene.add(sprite);
    */

    if (!addEdges) return;

    var avo = [];
    for (k=0; k<6; k++) {
      var v = h.vertices[k];
      avo.push(COLOR_OFFSET[v.color]);
    }
    s = new THREE.Mesh(new THREE.HexEdgeGeometry(BASE_HEIGHT, avo),
                       edgeMaterial);
    s.position.x = xoff;
    s.position.y = yoff;
    h.objs.push(s);
    scene.add(s);
}

for (var i=0; i<HEXES.length; i++) {
  for (var j=0; j<HEXES[i].length; j++) {
    updateHex(scene, HEXES[i][j]);
  }
}

var flipState = null;
var flippingHexes = null;
var doppelHexes = null;
var flippingNeighbors = null;
function flipHex() {
  var i, j, k, s, q;
  if (flipState == null) {
     flipState = { startTime: Date.now() };
     if (Math.random() < 0.5) {
       // change a vertex color
       var row = Math.floor(Math.random()*(HVERT.length));
       var col = Math.floor(Math.random()*(HVERT[row].length));
       var v = HVERT[row][col];
       var nv = v.clone();
       nv.color = randomColor();
       flipState.hexes = v.hexes;
       flipState.doppel = [];
       flipState.axes = [];
       for (i=0; i<flipState.hexes.length; i++) {
         flipState.doppel.push(flipState.hexes[i].clone());
         var which = flipState.hexes[i].vertices.indexOf(v);
         flipState.doppel[i].vertices[which] = nv;
         var m = new THREE.Matrix4().setRotationZ((which*60-30)*Math.PI/180);
         var axis = m.multiplyVector3(new THREE.Vector3(1,0,0));
         flipState.axes.push(axis);
       }
     } else {
       // change a core color
       var row = Math.floor(Math.random()*(HEXES.length));
       var col = Math.floor(Math.random()*(HEXES[row].length));
       flipState.hexes = [ HEXES[row][col] ];
       flipState.doppel = [ flipState.hexes[0].clone() ];
       flipState.doppel[0].color = randomColor();
       // pick axis at random, but quantize
       var angle = Math.floor(Math.random()*12) * 30 * Math.PI/180;
       var m = new THREE.Matrix4().setRotationZ(angle);
       var axis = m.multiplyVector3(new THREE.Vector3(1,0,0));
       flipState.axes = [ axis ];
     }

     if (flipState.hexes.length==0) {
       flipState = null;
       return; // pick another one later
     }

     // add edges, backs, find neighbors
     flipState.neighbors = [];
     for (i=0; i<flipState.hexes.length; i++) {
       // add edges
       updateHex(scene, flipState.hexes[i], true/*add edges*/);
       // make a doppelganger
       updateHex(scene, flipState.doppel[i], true/*add edges*/);
       // find all neighbors
       var n = flipState.hexes[i].neighbors();
       for (j=0; j<n.length; j++) {
         if (!HEXES[n[j][1]]) { continue; }
         var nn = HEXES[n[j][1]][n[j][0]];
         if (!nn) { continue; }
         flipState.neighbors.push(nn);
       }
     }
     // filter out redundant neighbors
     seen = {}
     function mkKey(hex) { return hex.x+","+hex.y; }
     for (i=0; i<flipState.hexes.length; i++) {
       seen[mkKey(flipState.hexes[i])] = 1;
     }
     var nn = [];
     for (i=0; i<flipState.neighbors.length; i++) {
       if (seen[mkKey(flipState.neighbors[i])]) { continue; }
       seen[mkKey(flipState.neighbors[i])] = 1;
       nn.push(flipState.neighbors[i]);
     }
     flipState.neighbors = nn;
     // add edges to neighbors
     for (i=0; i<flipState.neighbors.length; i++) {
       updateHex(scene, flipState.neighbors[i], true);
     }
  }
  // 0.25 degree per millisecond.
  var rotationAmt = (Date.now() - flipState.startTime) * 0.4 * Math.PI/180;
  for (i=0; i<flipState.hexes.length; i++) {
    q = new THREE.Quaternion().setFromAxisAngle(flipState.axes[i],-rotationAmt);
    for (j=0; j<flipState.hexes[i].objs.length; j++) {
      flipState.hexes[i].objs[j].quaternion = q;
      flipState.hexes[i].objs[j].useQuaternion = true;
    }
    q = new THREE.Quaternion().setFromAxisAngle(flipState.axes[i], -rotationAmt
                                                                   + Math.PI);
    for (j=0; j<flipState.doppel[i].objs.length; j++) {
      flipState.doppel[i].objs[j].quaternion = q;
      flipState.doppel[i].objs[j].useQuaternion = true;
    }
  }

  if (rotationAmt > Math.PI) {
    // fully rotated
    for (i=0; i<flipState.hexes.length; i++) {
      var h = flipState.hexes[i], d = flipState.doppel[i];
      // update all colors
      h.color = d.color;
      for (j=0; j<h.vertices.length; j++) {
        h.vertices[j].color = d.vertices[j].color;
      }
      updateHex(scene, h); // resets rotation, color, etc
      for (j=0; j<d.objs.length; j++) {
        scene.remove(d.objs[j]);
      }
    }
    for (i=0; i<flipState.neighbors.length; i++) {
      updateHex(scene, flipState.neighbors[i]);
    }
    flipState = null;
  }
}

renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
renderer.domElement.style.position = "relative";
container.appendChild(renderer.domElement);

stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
stats.domElement.style.right = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

var controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 3.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.noZoom = false;
controls.noPan = false;

controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;

controls.keys = [ 65, 83, 68 ];

function onDocumentMouseMove( event ) {
  event.preventDefault();
  mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
};

function animate() {
  requestAnimationFrame( animate );

  var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
  projector.unprojectVector( vector, camera );
  var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

  render();
  stats.update();
}

function render() {
  if (controls) controls.update();
  flipHex();

  renderer.render( scene, camera );
}
container.onmousemove = onDocumentMouseMove;
animate();
</script>
</body>
</html>
