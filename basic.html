<!DOCTYPE HTML>
<html>
<head>
<title>3d Tile Test</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style type="text/css">
body { background: white; color: black; padding: 0; margin: 0; }
</style>
<script src="Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/RequestAnimationFrame.js"></script>
<script src="js/Stats.js"></script>
</head>

<body>
<script type="text/javascript">
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;
var container = document.body;
var renderer = new THREE.WebGLRenderer();
var camera = new THREE.PerspectiveCamera(45, SCREEN_WIDTH/SCREEN_HEIGHT,
                                         1, 1000);
camera.position.z = 6;

var scene = new THREE.Scene();

var tileMaterial = new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture( 'obj/mountain-tile/tile-draft-1-128.png')});

var pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0.2;
pointLight.position.y = 1;
pointLight.position.z = 2.6;
scene.add(pointLight);

pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0.2;
pointLight.position.y = 1;
pointLight.position.z = -2.6;
scene.add(pointLight);

var SQRT3 = Math.sqrt(3);

THREE.HexCoreGeometry = function(centerOffset, edgeOffset) {
  THREE.Geometry.call(this);
  var v = new THREE.Vector3(1/4,SQRT3/4,edgeOffset);
  var m = new THREE.Matrix4();
  var i;
  this.vertices.push(new THREE.Vertex(new THREE.Vector3(0,0,centerOffset)));
  for (i=0; i<6; i++) {
    var vv = m.setRotationZ(i*60*Math.PI/180).multiplyVector3(v.clone());
    this.vertices.push(new THREE.Vertex(vv));
  }
  for (i=0; i<6; i++) {
    var fs = [ 0, 1+i, 1+((1+i)%6) ];
    this.faces.push( new THREE.Face3(fs[0], fs[1], fs[2]) );
    var uvs = [], v;
    for (j=0; j<3; j++) {
      v = this.vertices[fs[j]].position;
      uvs.push(new THREE.UV((v.x+1)/2, (v.y+1)/2));
    }
    this.faceVertexUvs[0/* uv layer 0 */].push(uvs);
  }

  this.computeCentroids();
  this.computeFaceNormals();
  console.log(this);
};
THREE.HexCoreGeometry.prototype = new THREE.Geometry();
THREE.HexCoreGeometry.prototype.contructor = THREE.HexCoreGeometry;

THREE.HexSegGeometry = function(segRot, uvRot, vertexOffset, centerOffset) {
  var i, j;
  THREE.Geometry.call(this);
  var segRotM = new THREE.Matrix4().setRotationZ(segRot*60*Math.PI/180);
  var  uvRotM = new THREE.Matrix4().setRotationZ( uvRot*60*Math.PI/180);

  var pts = [ [1/4,SQRT3/4,centerOffset],
              [3/8,SQRT3/8,centerOffset],
              [3/4,SQRT3/4,0],
              [1/2,SQRT3/2,vertexOffset],
              [  0,SQRT3/2,0],
              [  0,SQRT3/4,centerOffset] ];

  for (i=0; i<pts.length; i++) {
    this.vertices.push(new THREE.Vertex(segRotM.multiplyVector3(
                                        new THREE.Vector3
                                        (pts[i][0], pts[i][1], pts[i][2]))));
  }

  var fs = [ [ 0, 1, 2 ],
             [ 0, 2, 3 ],
             [ 0, 3, 4 ],
             [ 0, 4, 5 ] ];
  for (i=0; i<fs.length; i++) {
    this.faces.push( new THREE.Face3(fs[i][0], fs[i][1], fs[i][2]) );
    var uvs = [], v, p;
    for (j=0; j<3; j++) {
      p = pts[fs[i][j]];
      v = uvRotM.multiplyVector3(new THREE.Vector3(p[0], p[1], p[2]));
      uvs.push(new THREE.UV((v.x+1)/2, (v.y+1)/2));
    }
    this.faceVertexUvs[0/* uv layer 0 */].push(uvs);
  }

  this.computeCentroids();
  this.computeFaceNormals();
};
THREE.HexSegGeometry.prototype = new THREE.Geometry();
THREE.HexSegGeometry.prototype.contructor = THREE.HexSegGeometry;


var vo = [ 0, 0, -.1, -.1, .25, .25 ];
var s;
var q = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0),Math.PI/4);
for (var j=0; j<6; j++) {
  s = new THREE.Mesh(new THREE.HexSegGeometry(j,j,vo[j],0), tileMaterial);
  s.position.z = .1;
  scene.add(s);

  s = new THREE.Mesh(new THREE.HexSegGeometry(j,j,vo[j],0), tileMaterial);
  s.position.z = -.1;
  s.rotation.x = Math.PI;
  scene.add(s);
}
s = new THREE.Mesh(new THREE.HexCoreGeometry(.25, .1), tileMaterial);
scene.add(s);
s = new THREE.Mesh(new THREE.HexCoreGeometry(.25, .1), tileMaterial);
s.rotation.x = Math.PI;
scene.add(s);

renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
renderer.domElement.style.position = "relative";
container.appendChild(renderer.domElement);

stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
stats.domElement.style.right = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

var controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.noZoom = false;
controls.noPan = false;

controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;

controls.keys = [ 65, 83, 68 ];

function animate() {
  requestAnimationFrame( animate );

  render();
  stats.update();
}

function render() {
  if (controls) controls.update();

  renderer.render( scene, camera );
}
animate();
</script>
</body>
</html>
