<!DOCTYPE HTML>
<html>
<head>
<title>3d Tile Test</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style type="text/css">
body { background: #bfd1e5; color: black; padding: 0; margin: 0; }
</style>
<script src="Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/RequestAnimationFrame.js"></script>
<script src="js/Stats.js"></script>
<script src="3hex.js"></script>
<script src="hex.js"></script>
</head>

<body>
<script type="text/javascript">
if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
var SCREEN_WIDTH = window.innerWidth;
var SCREEN_HEIGHT = window.innerHeight;
var container = document.body;
var renderer = new THREE.WebGLRenderer();
var camera = new THREE.PerspectiveCamera(45, SCREEN_WIDTH/SCREEN_HEIGHT,
                                         1, 1000);
camera.position.z = 5;
camera.position.y = -5;
camera.lookAt(new THREE.Vector3(0,0,0));

var scene = new THREE.Scene();

var pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0.2;
pointLight.position.y = 1;
pointLight.position.z = 2.6;
scene.add(pointLight);

pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0.2;
pointLight.position.y = 1;
pointLight.position.z = -2.6;
scene.add(pointLight);

pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0;
pointLight.position.y = -5;
pointLight.position.z = 0;
//scene.add(pointLight);

pointLight = new THREE.PointLight(0xFFFFFF);
pointLight.position.x = 0;
pointLight.position.y = 5;
pointLight.position.z = 0;
scene.add(pointLight);

var tileMaterial = new THREE.MeshLambertMaterial({map:THREE.ImageUtils.loadTexture( 'obj/mountain-tile/tile-draft-1-128.png')});
var edgeTexture = THREE.ImageUtils.loadTexture( 'obj/mountain-tile/acorns.jpg');
//var edgeTexture = THREE.ImageUtils.loadTexture( 'UV.jpg' );
edgeTexture.wrapS = edgeTexture.wrapT = THREE.RepeatWrapping;
var edgeMaterial = new THREE.MeshLambertMaterial({map:edgeTexture});


var BASE_HEIGHT = .15;
var WATER_OFFSET = -.1, GRASS_OFFSET = 0, MOUNTAIN_OFFSET = .25;

// initialize the hexes and start drawin' 'em!
var x = hex_init();
var HVERT = x[0];
var HEXES = x[1];

var vo = [ GRASS_OFFSET, WATER_OFFSET, MOUNTAIN_OFFSET ];

function updateHex(scene, h, addEdges) {
    var i, k, s, n;
    if (h.objs && h.objs.length) {
      for (i=0; i<h.objs.length; i++) {
        scene.remove(h.objs[i]);
      }
    }
    h.objs = [];

    var xoff = (h.x-(HEXES[0].length/2))*1.5;
    var yoff = (h.y-(HEXES.length/2))*-SQRT3;
    if ((h.x%2)==1) { yoff += SQRT3/2; }

    var avo = [];
    for (k=0; k<6; k++) {
      var v = h.vertices[k];
      s = new THREE.Mesh(
          new THREE.HexSegGeometry(k, v.color*2, BASE_HEIGHT, vo[v.color], 0),
          tileMaterial);
      s.position.x = xoff;
      s.position.y = yoff;
      h.objs.push(s);
      scene.add(s);
      avo.push(vo[v.color]);
    }
    s = new THREE.Mesh(new THREE.HexCoreGeometry(BASE_HEIGHT, vo[h.color]),
                       tileMaterial);
    s.position.x = xoff;
    s.position.y = yoff;
    h.objs.push(s);
    // XXX only height reflects core type at the moment.
    scene.add(s);

    // always add edges if this is a boundary hex.
    n = h.neighbors();
    for (k=0; k<6; k++) {
      if (HEXES[n[k][1]] && HEXES[n[k][1]][n[k][0]]) continue;
      addEdges = true;
    }

    if (!addEdges) return;
    s = new THREE.Mesh(new THREE.HexEdgeGeometry(BASE_HEIGHT, avo),
                       edgeMaterial);
    s.position.x = xoff;
    s.position.y = yoff;
    h.objs.push(s);
    scene.add(s);
}

for (var i=0; i<HEXES.length; i++) {
  for (var j=0; j<HEXES[i].length; j++) {
    updateHex(scene, HEXES[i][j]);
  }
}

var flipState = null;
var flippingHexes = null;
var doppelHexes = null;
var flippingNeighbors = null;
function flipHex() {
  var i, j, k, s;
  if (flipState == null) {
     flipState = { startTime: Date.now() };
     var row = Math.floor(Math.random()*(HVERT.length));
     var col = Math.floor(Math.random()*(HVERT[row].length));
     flipState.hexes = HVERT[row][col].hexes;
     if (flipState.hexes.length==0) {
       flipState = null;
       return; // pick another one later
     }
     // add back side to these hexes!
     flipState.doppel = [];
     flipState.neighbors = [];
     for (i=0; i<flipState.hexes.length; i++) {
       // add edges
       updateHex(scene, flipState.hexes[i], true/*add edges*/);
       // make a doppelganger
       flipState.doppel.push(flipState.hexes[i].clone());
       updateHex(scene, flipState.doppel[i], true/*add edges*/);
       // add back sides to all the neighbors of these hexes
       var n = flipState.hexes[i].neighbors();
       for (j=0; j<n.length; j++) {
         if (!HEXES[n[j][1]]) { continue; }
         var nn = HEXES[n[j][1]][n[j][0]];
         if (!nn) { continue; }
         flipState.neighbors.push(nn);
       }
     }
     // filter out redundant neighbors
     seen = {}
     function mkKey(hex) { return hex.x+","+hex.y; }
     for (i=0; i<flipState.hexes.length; i++) {
       seen[mkKey(flipState.hexes[i])] = 1;
     }
     var nn = [];
     for (i=0; i<flipState.neighbors.length; i++) {
       if (seen[mkKey(flipState.neighbors[i])]) { continue; }
       seen[mkKey(flipState.neighbors[i])] = 1;
       nn.push(flipState.neighbors[i]);
     }
     flipState.neighbors = nn;
     for (i=0; i<flipState.neighbors.length; i++) {
       updateHex(scene, flipState.neighbors[i], true);
     }
     // pick axis at random
     var axis = new THREE.Vector3(Math.random(), Math.random(), 0);
     flipState.axis = axis.normalize();
  }
  // 0.25 degree per millisecond.
  var rotationAmt = (Date.now() - flipState.startTime) * 0.25 * Math.PI/180;
  var q1 = new THREE.Quaternion().setFromAxisAngle(flipState.axis, rotationAmt);
  var q2 = new THREE.Quaternion().setFromAxisAngle(flipState.axis, Math.PI + rotationAmt);
  for (i=0; i<flipState.hexes.length; i++) {
    for (j=0; j<flipState.hexes[i].objs.length; j++) {
      //flipState.hexes[i].objs[j].rotation.x = rotationAmt;
      flipState.hexes[i].objs[j].quaternion = q1;
      flipState.hexes[i].objs[j].useQuaternion = true;
    }
    for (j=0; j<flipState.doppel[i].objs.length; j++) {
      //flipState.doppel[i].objs[j].rotation.x = Math.PI + rotationAmt;
      flipState.doppel[i].objs[j].quaternion = q2;
      flipState.doppel[i].objs[j].useQuaternion = true;
    }
  }

  if (rotationAmt > Math.PI) {
    // fully rotated
    for (i=0; i<flipState.hexes.length; i++) {
      updateHex(scene, flipState.hexes[i]); // resets rotation
      for (j=0; j<flipState.doppel[i].objs.length; j++) {
        scene.remove(flipState.doppel[i].objs[j]);
      }
    }
    for (i=0; i<flipState.neighbors.length; i++) {
      updateHex(scene, flipState.neighbors[i]);
    }
    flipState = null;
  }
}

renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
renderer.domElement.style.position = "relative";
container.appendChild(renderer.domElement);

stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
stats.domElement.style.right = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

var controls = new THREE.TrackballControls( camera );
controls.rotateSpeed = 3.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.noZoom = false;
controls.noPan = false;

controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;

controls.keys = [ 65, 83, 68 ];

function animate() {
  requestAnimationFrame( animate );

  render();
  stats.update();
}

function render() {
  if (controls) controls.update();
  flipHex();

  renderer.render( scene, camera );
}
animate();
</script>
</body>
</html>
